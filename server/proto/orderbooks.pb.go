// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: orderbooks.proto

package orderbooks

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SnapshotMode int32

const (
	SnapshotMode_TIME  SnapshotMode = 0
	SnapshotMode_TICKS SnapshotMode = 1
)

var SnapshotMode_name = map[int32]string{
	0: "TIME",
	1: "TICKS",
}

var SnapshotMode_value = map[string]int32{
	"TIME":  0,
	"TICKS": 1,
}

func (x SnapshotMode) String() string {
	return proto.EnumName(SnapshotMode_name, int32(x))
}

func (SnapshotMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{0}
}

type OrderSide int32

const (
	OrderSide_BID OrderSide = 0
	OrderSide_ASK OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "BID",
	1: "ASK",
}

var OrderSide_value = map[string]int32{
	"BID": 0,
	"ASK": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}

func (OrderSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{1}
}

type EventType int32

const (
	EventType_INIT   EventType = 0
	EventType_ADD    EventType = 1
	EventType_CHANGE EventType = 2
	EventType_REMOVE EventType = 3
)

var EventType_name = map[int32]string{
	0: "INIT",
	1: "ADD",
	2: "CHANGE",
	3: "REMOVE",
}

var EventType_value = map[string]int32{
	"INIT":   0,
	"ADD":    1,
	"CHANGE": 2,
	"REMOVE": 3,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{2}
}

type EmptyMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyMsg) Reset()         { *m = EmptyMsg{} }
func (m *EmptyMsg) String() string { return proto.CompactTextString(m) }
func (*EmptyMsg) ProtoMessage()    {}
func (*EmptyMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{0}
}
func (m *EmptyMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyMsg.Merge(m, src)
}
func (m *EmptyMsg) XXX_Size() int {
	return m.Size()
}
func (m *EmptyMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyMsg proto.InternalMessageInfo

type GetExchangesResponseMsg struct {
	Count                uint32         `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Exchanges            []*ExchangeMsg `protobuf:"bytes,2,rep,name=exchanges,proto3" json:"exchanges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetExchangesResponseMsg) Reset()         { *m = GetExchangesResponseMsg{} }
func (m *GetExchangesResponseMsg) String() string { return proto.CompactTextString(m) }
func (*GetExchangesResponseMsg) ProtoMessage()    {}
func (*GetExchangesResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{1}
}
func (m *GetExchangesResponseMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetExchangesResponseMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetExchangesResponseMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetExchangesResponseMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetExchangesResponseMsg.Merge(m, src)
}
func (m *GetExchangesResponseMsg) XXX_Size() int {
	return m.Size()
}
func (m *GetExchangesResponseMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetExchangesResponseMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GetExchangesResponseMsg proto.InternalMessageInfo

func (m *GetExchangesResponseMsg) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetExchangesResponseMsg) GetExchanges() []*ExchangeMsg {
	if m != nil {
		return m.Exchanges
	}
	return nil
}

type ExchangeMsg struct {
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DateStart            *types.Timestamp `protobuf:"bytes,3,opt,name=date_start,json=dateStart,proto3" json:"date_start,omitempty"`
	DateEnd              *types.Timestamp `protobuf:"bytes,4,opt,name=date_end,json=dateEnd,proto3" json:"date_end,omitempty"`
	Pairs                []*PairMsg       `protobuf:"bytes,5,rep,name=pairs,proto3" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ExchangeMsg) Reset()         { *m = ExchangeMsg{} }
func (m *ExchangeMsg) String() string { return proto.CompactTextString(m) }
func (*ExchangeMsg) ProtoMessage()    {}
func (*ExchangeMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{2}
}
func (m *ExchangeMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeMsg.Merge(m, src)
}
func (m *ExchangeMsg) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeMsg proto.InternalMessageInfo

func (m *ExchangeMsg) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExchangeMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExchangeMsg) GetDateStart() *types.Timestamp {
	if m != nil {
		return m.DateStart
	}
	return nil
}

func (m *ExchangeMsg) GetDateEnd() *types.Timestamp {
	if m != nil {
		return m.DateEnd
	}
	return nil
}

func (m *ExchangeMsg) GetPairs() []*PairMsg {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type PairMsg struct {
	Base                 string           `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Quote                string           `protobuf:"bytes,2,opt,name=quote,proto3" json:"quote,omitempty"`
	DateStart            *types.Timestamp `protobuf:"bytes,3,opt,name=date_start,json=dateStart,proto3" json:"date_start,omitempty"`
	DateEnd              *types.Timestamp `protobuf:"bytes,4,opt,name=date_end,json=dateEnd,proto3" json:"date_end,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PairMsg) Reset()         { *m = PairMsg{} }
func (m *PairMsg) String() string { return proto.CompactTextString(m) }
func (*PairMsg) ProtoMessage()    {}
func (*PairMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{3}
}
func (m *PairMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PairMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PairMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PairMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PairMsg.Merge(m, src)
}
func (m *PairMsg) XXX_Size() int {
	return m.Size()
}
func (m *PairMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_PairMsg.DiscardUnknown(m)
}

var xxx_messageInfo_PairMsg proto.InternalMessageInfo

func (m *PairMsg) GetBase() string {
	if m != nil {
		return m.Base
	}
	return ""
}

func (m *PairMsg) GetQuote() string {
	if m != nil {
		return m.Quote
	}
	return ""
}

func (m *PairMsg) GetDateStart() *types.Timestamp {
	if m != nil {
		return m.DateStart
	}
	return nil
}

func (m *PairMsg) GetDateEnd() *types.Timestamp {
	if m != nil {
		return m.DateEnd
	}
	return nil
}

type EventsQueryMsg struct {
	Exchange  string           `protobuf:"bytes,1,opt,name=exchange,proto3" json:"exchange,omitempty"`
	DateStart *types.Timestamp `protobuf:"bytes,2,opt,name=date_start,json=dateStart,proto3" json:"date_start,omitempty"`
	DateEnd   *types.Timestamp `protobuf:"bytes,3,opt,name=date_end,json=dateEnd,proto3" json:"date_end,omitempty"`
	Pair      string           `protobuf:"bytes,4,opt,name=pair,proto3" json:"pair,omitempty"`
	// Types that are valid to be assigned to SnapshotInterval:
	//	*EventsQueryMsg_Interval
	//	*EventsQueryMsg_Ticks
	SnapshotInterval     isEventsQueryMsg_SnapshotInterval `protobuf_oneof:"snapshot_interval"`
	SnapshotSize         int64                             `protobuf:"varint,6,opt,name=snapshot_size,json=snapshotSize,proto3" json:"snapshot_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *EventsQueryMsg) Reset()         { *m = EventsQueryMsg{} }
func (m *EventsQueryMsg) String() string { return proto.CompactTextString(m) }
func (*EventsQueryMsg) ProtoMessage()    {}
func (*EventsQueryMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{4}
}
func (m *EventsQueryMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsQueryMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsQueryMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsQueryMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsQueryMsg.Merge(m, src)
}
func (m *EventsQueryMsg) XXX_Size() int {
	return m.Size()
}
func (m *EventsQueryMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsQueryMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EventsQueryMsg proto.InternalMessageInfo

type isEventsQueryMsg_SnapshotInterval interface {
	isEventsQueryMsg_SnapshotInterval()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EventsQueryMsg_Interval struct {
	Interval string `protobuf:"bytes,5,opt,name=interval,proto3,oneof" json:"interval,omitempty"`
}
type EventsQueryMsg_Ticks struct {
	Ticks int64 `protobuf:"varint,7,opt,name=ticks,proto3,oneof" json:"ticks,omitempty"`
}

func (*EventsQueryMsg_Interval) isEventsQueryMsg_SnapshotInterval() {}
func (*EventsQueryMsg_Ticks) isEventsQueryMsg_SnapshotInterval()    {}

func (m *EventsQueryMsg) GetSnapshotInterval() isEventsQueryMsg_SnapshotInterval {
	if m != nil {
		return m.SnapshotInterval
	}
	return nil
}

func (m *EventsQueryMsg) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *EventsQueryMsg) GetDateStart() *types.Timestamp {
	if m != nil {
		return m.DateStart
	}
	return nil
}

func (m *EventsQueryMsg) GetDateEnd() *types.Timestamp {
	if m != nil {
		return m.DateEnd
	}
	return nil
}

func (m *EventsQueryMsg) GetPair() string {
	if m != nil {
		return m.Pair
	}
	return ""
}

func (m *EventsQueryMsg) GetInterval() string {
	if x, ok := m.GetSnapshotInterval().(*EventsQueryMsg_Interval); ok {
		return x.Interval
	}
	return ""
}

func (m *EventsQueryMsg) GetTicks() int64 {
	if x, ok := m.GetSnapshotInterval().(*EventsQueryMsg_Ticks); ok {
		return x.Ticks
	}
	return 0
}

func (m *EventsQueryMsg) GetSnapshotSize() int64 {
	if m != nil {
		return m.SnapshotSize
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventsQueryMsg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventsQueryMsg_Interval)(nil),
		(*EventsQueryMsg_Ticks)(nil),
	}
}

type SnapshotMsg struct {
	Timestamp            *types.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Exchange             string           `protobuf:"bytes,2,opt,name=exchange,proto3" json:"exchange,omitempty"`
	Pair                 string           `protobuf:"bytes,3,opt,name=pair,proto3" json:"pair,omitempty"`
	Orders               []*Event         `protobuf:"bytes,4,rep,name=orders,proto3" json:"orders,omitempty"`
	Events               []*Event         `protobuf:"bytes,5,rep,name=events,proto3" json:"events,omitempty"`
	SessionId            int64            `protobuf:"varint,6,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Counter              int64            `protobuf:"varint,7,opt,name=counter,proto3" json:"counter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SnapshotMsg) Reset()         { *m = SnapshotMsg{} }
func (m *SnapshotMsg) String() string { return proto.CompactTextString(m) }
func (*SnapshotMsg) ProtoMessage()    {}
func (*SnapshotMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{5}
}
func (m *SnapshotMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotMsg.Merge(m, src)
}
func (m *SnapshotMsg) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotMsg proto.InternalMessageInfo

func (m *SnapshotMsg) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *SnapshotMsg) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *SnapshotMsg) GetPair() string {
	if m != nil {
		return m.Pair
	}
	return ""
}

func (m *SnapshotMsg) GetOrders() []*Event {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *SnapshotMsg) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *SnapshotMsg) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SnapshotMsg) GetCounter() int64 {
	if m != nil {
		return m.Counter
	}
	return 0
}

type Event struct {
	Timestamp            int64     `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	OrderSide            OrderSide `protobuf:"varint,2,opt,name=order_side,json=orderSide,proto3,enum=orderbooks.OrderSide" json:"order_side,omitempty"`
	Amount               float32   `protobuf:"fixed32,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Price                float32   `protobuf:"fixed32,4,opt,name=price,proto3" json:"price,omitempty"`
	EventType            EventType `protobuf:"varint,5,opt,name=event_type,json=eventType,proto3,enum=orderbooks.EventType" json:"event_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_0defe743243468f7, []int{6}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Event) GetOrderSide() OrderSide {
	if m != nil {
		return m.OrderSide
	}
	return OrderSide_BID
}

func (m *Event) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Event) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Event) GetEventType() EventType {
	if m != nil {
		return m.EventType
	}
	return EventType_INIT
}

func init() {
	proto.RegisterEnum("orderbooks.SnapshotMode", SnapshotMode_name, SnapshotMode_value)
	proto.RegisterEnum("orderbooks.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("orderbooks.EventType", EventType_name, EventType_value)
	proto.RegisterType((*EmptyMsg)(nil), "orderbooks.EmptyMsg")
	proto.RegisterType((*GetExchangesResponseMsg)(nil), "orderbooks.GetExchangesResponseMsg")
	proto.RegisterType((*ExchangeMsg)(nil), "orderbooks.ExchangeMsg")
	proto.RegisterType((*PairMsg)(nil), "orderbooks.PairMsg")
	proto.RegisterType((*EventsQueryMsg)(nil), "orderbooks.EventsQueryMsg")
	proto.RegisterType((*SnapshotMsg)(nil), "orderbooks.SnapshotMsg")
	proto.RegisterType((*Event)(nil), "orderbooks.Event")
}

func init() { proto.RegisterFile("orderbooks.proto", fileDescriptor_0defe743243468f7) }

var fileDescriptor_0defe743243468f7 = []byte{
	// 756 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xcb, 0x4e, 0xdb, 0x4c,
	0x14, 0x8e, 0xed, 0xdc, 0x7c, 0x12, 0x90, 0x19, 0xf8, 0xc1, 0x8a, 0x80, 0x3f, 0x32, 0x9b, 0xc0,
	0x22, 0x54, 0x69, 0xa9, 0xda, 0x25, 0x21, 0x6e, 0x12, 0xd1, 0x40, 0x3b, 0x89, 0xba, 0x8d, 0x9c,
	0x78, 0x08, 0x16, 0xc4, 0x76, 0x3d, 0x13, 0x54, 0x78, 0x80, 0x3e, 0x48, 0xa5, 0x3e, 0x41, 0x1f,
	0xa0, 0xdb, 0xae, 0xaa, 0x3e, 0x42, 0xc5, 0x93, 0x54, 0x33, 0xbe, 0xe0, 0xa4, 0xad, 0xa8, 0xa8,
	0xd4, 0xdd, 0x39, 0x67, 0x3e, 0x1f, 0x9f, 0xef, 0x3b, 0x17, 0xd0, 0xbc, 0xc0, 0x26, 0xc1, 0xc8,
	0xf3, 0x2e, 0x68, 0xdd, 0x0f, 0x3c, 0xe6, 0x21, 0xb8, 0x8b, 0x54, 0xfe, 0x9f, 0x78, 0xde, 0xe4,
	0x92, 0xec, 0x8b, 0x97, 0xd1, 0xec, 0x6c, 0x9f, 0x39, 0x53, 0x42, 0x99, 0x35, 0xf5, 0x43, 0xb0,
	0x01, 0x50, 0x34, 0xa7, 0x3e, 0xbb, 0xee, 0xd1, 0x89, 0x71, 0x06, 0x1b, 0x6d, 0xc2, 0xcc, 0x77,
	0xe3, 0x73, 0xcb, 0x9d, 0x10, 0x8a, 0x09, 0xf5, 0x3d, 0x97, 0x92, 0x1e, 0x9d, 0xa0, 0x35, 0xc8,
	0x8d, 0xbd, 0x99, 0xcb, 0x74, 0xa9, 0x2a, 0xd5, 0x96, 0x70, 0xe8, 0xa0, 0x03, 0x50, 0x49, 0x8c,
	0xd6, 0xe5, 0xaa, 0x52, 0x2b, 0x35, 0x36, 0xea, 0xa9, 0x7a, 0xe2, 0x54, 0x3d, 0x3a, 0xc1, 0x77,
	0x48, 0xe3, 0xab, 0x04, 0xa5, 0xd4, 0x13, 0x5a, 0x06, 0xd9, 0xb1, 0x45, 0x66, 0x15, 0xcb, 0x8e,
	0x8d, 0x10, 0x64, 0x5d, 0x6b, 0x4a, 0x74, 0x59, 0x44, 0x84, 0x8d, 0x9e, 0x03, 0xd8, 0x16, 0x23,
	0x43, 0xca, 0xac, 0x80, 0xe9, 0x4a, 0x55, 0xaa, 0x95, 0x1a, 0x95, 0x7a, 0xc8, 0xae, 0x1e, 0xb3,
	0xab, 0x0f, 0x62, 0x76, 0x58, 0xe5, 0xe8, 0x3e, 0x07, 0xa3, 0x03, 0x28, 0x8a, 0x4f, 0x89, 0x6b,
	0xeb, 0xd9, 0x7b, 0x3f, 0x2c, 0x70, 0xac, 0xe9, 0xda, 0x68, 0x17, 0x72, 0xbe, 0xe5, 0x04, 0x54,
	0xcf, 0x09, 0x62, 0xab, 0x69, 0x62, 0xaf, 0x2c, 0x27, 0xe0, 0xa4, 0x42, 0x84, 0xf1, 0x51, 0x82,
	0x42, 0x14, 0xe2, 0xc5, 0x8f, 0x2c, 0x4a, 0x22, 0x3a, 0xc2, 0xe6, 0xea, 0xbd, 0x9d, 0x79, 0x2c,
	0x66, 0x14, 0x3a, 0xff, 0x9e, 0x92, 0xf1, 0x41, 0x86, 0x65, 0xf3, 0x8a, 0xb8, 0x8c, 0xbe, 0x9e,
	0x91, 0x80, 0xf7, 0x1c, 0x55, 0xa0, 0x18, 0x37, 0x26, 0x2a, 0x39, 0xf1, 0x17, 0x0a, 0x94, 0x1f,
	0x5a, 0xa0, 0xf2, 0xe7, 0x9a, 0x23, 0xc8, 0x72, 0x45, 0x05, 0x27, 0x15, 0x0b, 0x1b, 0x6d, 0x42,
	0xd1, 0x71, 0x19, 0x09, 0xae, 0xac, 0x4b, 0x3d, 0xc7, 0xe3, 0x9d, 0x0c, 0x4e, 0x22, 0x68, 0x1d,
	0x72, 0xcc, 0x19, 0x5f, 0x50, 0xbd, 0x50, 0x95, 0x6a, 0x4a, 0x27, 0x83, 0x43, 0x17, 0xed, 0xc0,
	0x12, 0x75, 0x2d, 0x9f, 0x9e, 0x7b, 0x6c, 0x48, 0x9d, 0x1b, 0xa2, 0xe7, 0xf9, 0x3b, 0x2e, 0xc7,
	0xc1, 0xbe, 0x73, 0x43, 0x9a, 0xab, 0xb0, 0x92, 0x80, 0xe2, 0x8c, 0xc6, 0x7b, 0x19, 0x4a, 0xfd,
	0x28, 0xca, 0x15, 0x7a, 0x06, 0x6a, 0xb2, 0x34, 0x42, 0xa2, 0x7b, 0x44, 0x48, 0xc0, 0x73, 0xda,
	0xca, 0x0b, 0xda, 0xc6, 0x4c, 0x95, 0x14, 0xd3, 0x5d, 0xc8, 0x8b, 0x19, 0xa3, 0x7a, 0x56, 0x8c,
	0xdc, 0xca, 0xdc, 0x2e, 0xf1, 0xbe, 0xe1, 0x08, 0xc0, 0xa1, 0x44, 0x34, 0x32, 0x9a, 0xce, 0x5f,
	0x41, 0x43, 0x00, 0xda, 0x02, 0xa0, 0x84, 0x52, 0xc7, 0x73, 0x87, 0x8e, 0x1d, 0xc9, 0xa0, 0x46,
	0x91, 0xae, 0x8d, 0x74, 0x28, 0x88, 0x65, 0x26, 0x41, 0x28, 0x21, 0x8e, 0x5d, 0xe3, 0xb3, 0x04,
	0x39, 0x91, 0x0a, 0x6d, 0x2e, 0x4a, 0xa0, 0xa4, 0x69, 0x3e, 0x81, 0xf0, 0xe2, 0x0c, 0xa9, 0x63,
	0x87, 0x44, 0x97, 0x1b, 0xff, 0xa5, 0xeb, 0x39, 0xe5, 0x66, 0xdf, 0xb1, 0x09, 0x56, 0xbd, 0xd8,
	0x44, 0xeb, 0x90, 0xb7, 0xa6, 0xe2, 0xa4, 0x70, 0x09, 0x64, 0x1c, 0x79, 0x7c, 0x57, 0xfc, 0xc0,
	0x19, 0x13, 0x31, 0x03, 0x32, 0x0e, 0x1d, 0xfe, 0x0f, 0x41, 0x67, 0xc8, 0xae, 0x7d, 0x22, 0xc6,
	0x60, 0xe1, 0x1f, 0xa2, 0xd0, 0xc1, 0xb5, 0x4f, 0xb0, 0x4a, 0x62, 0x73, 0x6f, 0x07, 0xca, 0x49,
	0x27, 0x3d, 0x9b, 0xa0, 0x22, 0x64, 0x07, 0xdd, 0x9e, 0xa9, 0x65, 0x90, 0x0a, 0xb9, 0x41, 0xf7,
	0xe8, 0xb8, 0xaf, 0x49, 0x7b, 0x5b, 0xa0, 0x26, 0x05, 0xa2, 0x02, 0x28, 0xcd, 0x6e, 0x4b, 0xcb,
	0x70, 0xe3, 0xb0, 0x7f, 0xac, 0x49, 0x7b, 0x4f, 0x41, 0x4d, 0x72, 0xf3, 0x04, 0xdd, 0x93, 0xee,
	0x20, 0x7a, 0x6f, 0xb5, 0x34, 0x09, 0x01, 0xe4, 0x8f, 0x3a, 0x87, 0x27, 0x6d, 0x53, 0x93, 0xb9,
	0x8d, 0xcd, 0xde, 0xe9, 0x1b, 0x53, 0x53, 0x1a, 0x9f, 0x64, 0x00, 0x91, 0xb7, 0xc9, 0xeb, 0x43,
	0xc7, 0x50, 0x4e, 0xdf, 0x56, 0xb4, 0x36, 0x57, 0x7c, 0x74, 0x81, 0x2b, 0x3b, 0xe9, 0xe8, 0x6f,
	0x6e, 0xb1, 0x91, 0x41, 0x2f, 0xa0, 0x24, 0x16, 0x38, 0xdc, 0x65, 0x54, 0xf9, 0x49, 0x88, 0x64,
	0xbf, 0x2b, 0x73, 0xf7, 0x38, 0x35, 0xd6, 0x46, 0xe6, 0x91, 0xc4, 0xf3, 0xb4, 0x09, 0x7b, 0xe9,
	0x5c, 0x91, 0x96, 0xc5, 0xac, 0x87, 0xe7, 0xe9, 0xc0, 0x52, 0x9b, 0xb0, 0x23, 0x6b, 0x7c, 0x4e,
	0xec, 0xbf, 0xca, 0xd4, 0x2c, 0x7f, 0xb9, 0xdd, 0x96, 0xbe, 0xdd, 0x6e, 0x4b, 0xdf, 0x6f, 0xb7,
	0xa5, 0x51, 0x5e, 0xec, 0xd7, 0xe3, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1b, 0xc7, 0xe0, 0xf9,
	0xe4, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OrderBooksClient is the client API for OrderBooks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderBooksClient interface {
	GetExchanges(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*GetExchangesResponseMsg, error)
	QueryEvents(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_QueryEventsClient, error)
	GetLiveData(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_GetLiveDataClient, error)
	GetCachedData(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_GetCachedDataClient, error)
}

type orderBooksClient struct {
	cc *grpc.ClientConn
}

func NewOrderBooksClient(cc *grpc.ClientConn) OrderBooksClient {
	return &orderBooksClient{cc}
}

func (c *orderBooksClient) GetExchanges(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*GetExchangesResponseMsg, error) {
	out := new(GetExchangesResponseMsg)
	err := c.cc.Invoke(ctx, "/orderbooks.OrderBooks/GetExchanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderBooksClient) QueryEvents(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_QueryEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OrderBooks_serviceDesc.Streams[0], "/orderbooks.OrderBooks/QueryEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderBooksQueryEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderBooks_QueryEventsClient interface {
	Recv() (*SnapshotMsg, error)
	grpc.ClientStream
}

type orderBooksQueryEventsClient struct {
	grpc.ClientStream
}

func (x *orderBooksQueryEventsClient) Recv() (*SnapshotMsg, error) {
	m := new(SnapshotMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orderBooksClient) GetLiveData(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_GetLiveDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OrderBooks_serviceDesc.Streams[1], "/orderbooks.OrderBooks/GetLiveData", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderBooksGetLiveDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderBooks_GetLiveDataClient interface {
	Recv() (*SnapshotMsg, error)
	grpc.ClientStream
}

type orderBooksGetLiveDataClient struct {
	grpc.ClientStream
}

func (x *orderBooksGetLiveDataClient) Recv() (*SnapshotMsg, error) {
	m := new(SnapshotMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orderBooksClient) GetCachedData(ctx context.Context, in *EventsQueryMsg, opts ...grpc.CallOption) (OrderBooks_GetCachedDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OrderBooks_serviceDesc.Streams[2], "/orderbooks.OrderBooks/GetCachedData", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderBooksGetCachedDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderBooks_GetCachedDataClient interface {
	Recv() (*SnapshotMsg, error)
	grpc.ClientStream
}

type orderBooksGetCachedDataClient struct {
	grpc.ClientStream
}

func (x *orderBooksGetCachedDataClient) Recv() (*SnapshotMsg, error) {
	m := new(SnapshotMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OrderBooksServer is the server API for OrderBooks service.
type OrderBooksServer interface {
	GetExchanges(context.Context, *EmptyMsg) (*GetExchangesResponseMsg, error)
	QueryEvents(*EventsQueryMsg, OrderBooks_QueryEventsServer) error
	GetLiveData(*EventsQueryMsg, OrderBooks_GetLiveDataServer) error
	GetCachedData(*EventsQueryMsg, OrderBooks_GetCachedDataServer) error
}

// UnimplementedOrderBooksServer can be embedded to have forward compatible implementations.
type UnimplementedOrderBooksServer struct {
}

func (*UnimplementedOrderBooksServer) GetExchanges(ctx context.Context, req *EmptyMsg) (*GetExchangesResponseMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExchanges not implemented")
}
func (*UnimplementedOrderBooksServer) QueryEvents(req *EventsQueryMsg, srv OrderBooks_QueryEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryEvents not implemented")
}
func (*UnimplementedOrderBooksServer) GetLiveData(req *EventsQueryMsg, srv OrderBooks_GetLiveDataServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLiveData not implemented")
}
func (*UnimplementedOrderBooksServer) GetCachedData(req *EventsQueryMsg, srv OrderBooks_GetCachedDataServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCachedData not implemented")
}

func RegisterOrderBooksServer(s *grpc.Server, srv OrderBooksServer) {
	s.RegisterService(&_OrderBooks_serviceDesc, srv)
}

func _OrderBooks_GetExchanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderBooksServer).GetExchanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderbooks.OrderBooks/GetExchanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderBooksServer).GetExchanges(ctx, req.(*EmptyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderBooks_QueryEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventsQueryMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderBooksServer).QueryEvents(m, &orderBooksQueryEventsServer{stream})
}

type OrderBooks_QueryEventsServer interface {
	Send(*SnapshotMsg) error
	grpc.ServerStream
}

type orderBooksQueryEventsServer struct {
	grpc.ServerStream
}

func (x *orderBooksQueryEventsServer) Send(m *SnapshotMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _OrderBooks_GetLiveData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventsQueryMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderBooksServer).GetLiveData(m, &orderBooksGetLiveDataServer{stream})
}

type OrderBooks_GetLiveDataServer interface {
	Send(*SnapshotMsg) error
	grpc.ServerStream
}

type orderBooksGetLiveDataServer struct {
	grpc.ServerStream
}

func (x *orderBooksGetLiveDataServer) Send(m *SnapshotMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _OrderBooks_GetCachedData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventsQueryMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderBooksServer).GetCachedData(m, &orderBooksGetCachedDataServer{stream})
}

type OrderBooks_GetCachedDataServer interface {
	Send(*SnapshotMsg) error
	grpc.ServerStream
}

type orderBooksGetCachedDataServer struct {
	grpc.ServerStream
}

func (x *orderBooksGetCachedDataServer) Send(m *SnapshotMsg) error {
	return x.ServerStream.SendMsg(m)
}

var _OrderBooks_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderbooks.OrderBooks",
	HandlerType: (*OrderBooksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetExchanges",
			Handler:    _OrderBooks_GetExchanges_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryEvents",
			Handler:       _OrderBooks_QueryEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLiveData",
			Handler:       _OrderBooks_GetLiveData_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCachedData",
			Handler:       _OrderBooks_GetCachedData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "orderbooks.proto",
}

func (m *EmptyMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetExchangesResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetExchangesResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetExchangesResponseMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Exchanges) > 0 {
		for iNdEx := len(m.Exchanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exchanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrderbooks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Count != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pairs) > 0 {
		for iNdEx := len(m.Pairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrderbooks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DateEnd != nil {
		{
			size, err := m.DateEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DateStart != nil {
		{
			size, err := m.DateStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PairMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PairMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PairMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DateEnd != nil {
		{
			size, err := m.DateEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DateStart != nil {
		{
			size, err := m.DateStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Quote) > 0 {
		i -= len(m.Quote)
		copy(dAtA[i:], m.Quote)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Quote)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Base) > 0 {
		i -= len(m.Base)
		copy(dAtA[i:], m.Base)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Base)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsQueryMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsQueryMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsQueryMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SnapshotInterval != nil {
		{
			size := m.SnapshotInterval.Size()
			i -= size
			if _, err := m.SnapshotInterval.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SnapshotSize != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.SnapshotSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Pair) > 0 {
		i -= len(m.Pair)
		copy(dAtA[i:], m.Pair)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Pair)))
		i--
		dAtA[i] = 0x22
	}
	if m.DateEnd != nil {
		{
			size, err := m.DateEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DateStart != nil {
		{
			size, err := m.DateStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Exchange) > 0 {
		i -= len(m.Exchange)
		copy(dAtA[i:], m.Exchange)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Exchange)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsQueryMsg_Interval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsQueryMsg_Interval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Interval)
	copy(dAtA[i:], m.Interval)
	i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Interval)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *EventsQueryMsg_Ticks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsQueryMsg_Ticks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintOrderbooks(dAtA, i, uint64(m.Ticks))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *SnapshotMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Counter != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x38
	}
	if m.SessionId != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrderbooks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrderbooks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Pair) > 0 {
		i -= len(m.Pair)
		copy(dAtA[i:], m.Pair)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Pair)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Exchange) > 0 {
		i -= len(m.Exchange)
		copy(dAtA[i:], m.Exchange)
		i = encodeVarintOrderbooks(dAtA, i, uint64(len(m.Exchange)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrderbooks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EventType != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x28
	}
	if m.Price != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
		i--
		dAtA[i] = 0x25
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x1d
	}
	if m.OrderSide != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.OrderSide))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintOrderbooks(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrderbooks(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrderbooks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmptyMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetExchangesResponseMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovOrderbooks(uint64(m.Count))
	}
	if len(m.Exchanges) > 0 {
		for _, e := range m.Exchanges {
			l = e.Size()
			n += 1 + l + sovOrderbooks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateStart != nil {
		l = m.DateStart.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateEnd != nil {
		l = m.DateEnd.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovOrderbooks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PairMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Base)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	l = len(m.Quote)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateStart != nil {
		l = m.DateStart.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateEnd != nil {
		l = m.DateEnd.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventsQueryMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exchange)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateStart != nil {
		l = m.DateStart.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.DateEnd != nil {
		l = m.DateEnd.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	l = len(m.Pair)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if m.SnapshotInterval != nil {
		n += m.SnapshotInterval.Size()
	}
	if m.SnapshotSize != 0 {
		n += 1 + sovOrderbooks(uint64(m.SnapshotSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventsQueryMsg_Interval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Interval)
	n += 1 + l + sovOrderbooks(uint64(l))
	return n
}
func (m *EventsQueryMsg_Ticks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOrderbooks(uint64(m.Ticks))
	return n
}
func (m *SnapshotMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	l = len(m.Exchange)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	l = len(m.Pair)
	if l > 0 {
		n += 1 + l + sovOrderbooks(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovOrderbooks(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovOrderbooks(uint64(l))
		}
	}
	if m.SessionId != 0 {
		n += 1 + sovOrderbooks(uint64(m.SessionId))
	}
	if m.Counter != 0 {
		n += 1 + sovOrderbooks(uint64(m.Counter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovOrderbooks(uint64(m.Timestamp))
	}
	if m.OrderSide != 0 {
		n += 1 + sovOrderbooks(uint64(m.OrderSide))
	}
	if m.Amount != 0 {
		n += 5
	}
	if m.Price != 0 {
		n += 5
	}
	if m.EventType != 0 {
		n += 1 + sovOrderbooks(uint64(m.EventType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOrderbooks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrderbooks(x uint64) (n int) {
	return sovOrderbooks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetExchangesResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetExchangesResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetExchangesResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchanges = append(m.Exchanges, &ExchangeMsg{})
			if err := m.Exchanges[len(m.Exchanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateStart == nil {
				m.DateStart = &types.Timestamp{}
			}
			if err := m.DateStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateEnd == nil {
				m.DateEnd = &types.Timestamp{}
			}
			if err := m.DateEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &PairMsg{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PairMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PairMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PairMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateStart == nil {
				m.DateStart = &types.Timestamp{}
			}
			if err := m.DateStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateEnd == nil {
				m.DateEnd = &types.Timestamp{}
			}
			if err := m.DateEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsQueryMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsQueryMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsQueryMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateStart == nil {
				m.DateStart = &types.Timestamp{}
			}
			if err := m.DateStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateEnd == nil {
				m.DateEnd = &types.Timestamp{}
			}
			if err := m.DateEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotInterval = &EventsQueryMsg_Interval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotSize", wireType)
			}
			m.SnapshotSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticks", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotInterval = &EventsQueryMsg_Ticks{v}
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &Event{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderbooks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSide", wireType)
			}
			m.OrderSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderSide |= OrderSide(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrderbooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrderbooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrderbooks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrderbooks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrderbooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrderbooks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrderbooks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrderbooks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrderbooks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrderbooks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrderbooks = fmt.Errorf("proto: unexpected end of group")
)
